---
title: "pedo_Augur_Analysis"
author: "EmilieSanvito"
date: "2023-10-05"
output: html_document
---
###Pedologie projet

##data organization

```{r libraries}
#empty your work environment
rm(list=ls()) 

#load all libraries
library(tidyverse)
library(readxl)
library(dplyr)

#library(ggforce)   #look again why I used it
library(knitr)

library(car)          #for anvoa
library(ggfortify)   #for autoplot function

library(datasets)   #library for KW test
library(FSA)        #library for dunn test

```

```{r upload and structure data}
#import data from last year project (36 Augur in the P16)
dataAugur2022 <- read_excel("DataAuger2022.xlsx", na = "NA")  

#create a new column for topography that only contains the number of the topography 
dataAugur2022$topo <- as.numeric(gsub("[^0-9]+", "", dataAugur2022$topographie))
#6: bas fonds
#5: versant bas de pente
#4: versant mi-pente
#3: versant haut de pente
#2: ...?
#1: plateau

#import botany data
Botany <- read_excel("DataAuger2022.xlsx", na = "NA", sheet = "Data Giacomo")

#remove NA objects and select specific variables of interest
Botany <- Botany %>% 
  na.omit %>%
  select(c("TreeID", "Family", "Genus", "species", "DBH", "Xutm", "Yutm"))

```

```{r rename titles in Augur data}

dataAugur2022 <- dataAugur2022 %>% rename_at('% pente', ~'pente')
dataAugur2022 <- dataAugur2022 %>% rename_at('Numéro horizon', ~'horizon')
dataAugur2022 <- dataAugur2022 %>% rename_at('profondeur limite inférieure (cm)2', ~'depth_inf')
dataAugur2022 <- dataAugur2022 %>% rename_at('profondeur limite supérieure (cm)', ~'depth_sup')
dataAugur2022 <- dataAugur2022 %>% rename_at('Epaisseur (cm)', ~'epaisseur')
dataAugur2022 <- dataAugur2022 %>% rename_at('Texture corrigée 2023', ~'Texture_2023')
dataAugur2022 <- dataAugur2022 %>% rename_at('EG %', ~'stone_elements')
dataAugur2022 <- dataAugur2022 %>% rename_at('Réserve eau utile (mm) NEW...35', ~'water_reservoir')

```


We have 36 Augur points, of which some do not have corrected texture analysis so we do not consider these (22) and of these 22 there are 17 that are on the slope. Of these 17 only 13 have high silt class present in their texture data. Of the 22 texture available over all topography, there are 16 that have high texture present.


## check for correlation between topography and high silt depth occurences

do also check of correlation without the "intermediate" samples (samples with no high silt in the Augur), as the value given to the "intermediate" samples might cause changes to the value of correlation

```{r part for correlation test}
#create a cleaner dataframe with only necessary informations
Augur_cor <- dataAugur2022 %>% 
  select(c("sondage_N", "depth_sup", "texture", "Texture_2023", "topo", "arbre_plus_proche"))

#create new texture variable that contains some additional corrected textures
Augur_cor$final_texture <- ifelse(
  is.na(dataAugur2022$Texture_2023) & !(dataAugur2022$sondage_N %in% c("15.1", "15.2", "15.5", "15.7", "19.5", "19.7", "20.5")),
  dataAugur2022$texture,
  dataAugur2022$Texture_2023
)

#create dataframe with only final texture as texture, and then only eliminate the rows for which we have no data for
Augur_cor <- Augur_cor %>%
  select(c("sondage_N", "depth_sup", "final_texture", "topo")) %>%
  na.omit

#create new column with textures divided in three classes based upon their presence of silt
Augur_cor$Silt_class <- ifelse(Augur_cor$final_texture %in% c("A", "Alo", "AS"), "low", ifelse(Augur_cor$final_texture %in% c("SL", "SA", "S"), "intermediate", "high"))

#For every Augur point you define depth at which silt concentration becomes high, or if intermediate that it is 100 (!!Important to check this)
Augur_cor <- Augur_cor %>%
  group_by(sondage_N) %>%
  mutate(
    final_depth = ifelse(any(Silt_class == "high"), 
                         min(depth_sup[Silt_class == "high"]), 
                         100)
  ) %>%
  ungroup() %>%
  distinct(sondage_N, .keep_all = TRUE) %>%
  select(sondage_N, final_depth, topo)

#import elevation data of topography
Elevation <- read.csv("Elevation_exact.csv")

#merge two dataframes 
Elevation <- Elevation %>%
  select(c("sondage_N", "Elevation_Paracou_depth1")) %>%
  merge(Augur_cor, by.x = 'sondage_N', by.y = 'sondage_N')

#correlation test between topography and high silt depth appearance, spearman method instead of pearson due to non-normality (of final depth because much more values of no HSD appearance)
cor(Elevation$Elevation_Paracou_depth1, Elevation$final_depth, method = "spearman")

cor.test(Elevation$Elevation_Paracou_depth1, Elevation$final_depth, method = 
c("spearman"))

#Filter out rows where final_depth is 100
Elevation_filtered <- Elevation[Elevation$final_depth != 100,]

# Correlation test between topography and high silt depth appearance, pearson method
shapiro.test(Elevation_filtered$final_depth)
shapiro.test(Elevation_filtered$Elevation_Paracou_depth1)

cor(Elevation_filtered$Elevation_Paracou_depth1, Elevation_filtered$final_depth, method = "pearson")

cor.test(Elevation_filtered$Elevation_Paracou_depth1, Elevation_filtered$final_depth, method = "pearson")


```

There is a correlation of - 0.634 between the topography and the depth at which silt occurs in high levels. This means that with higher elevation silt appears quicker in high concentrations (depth gets smaller).
Without the intermediate: r = -0.593, it is only a little lower than earlier

=> this causes multicollinearity in our model
the effects of multicollinearity are that the predictions are way less precise and can quickly completely change of direction/relationship.     

```{r little data visualisation for correlation}
hist(Elevation$final_depth)
hist(Elevation$Elevation_Paracou_depth1)
# ggplot(Elevation, aes(x=Elevation_Paracou_depth1)) + geom_histogram()
# ggplot(Elevation, aes(x=final_depth)) + geom_histogram()

ggplot(Elevation, aes(x=as.factor(topo), y=final_depth)) + geom_boxplot() + geom_point()
ggplot(Elevation, aes(x=Elevation_Paracou_depth1, y=final_depth)) + geom_point() + geom_smooth(method = "lm")

#create graph without Augurs that do not have high silt occurrences (they are all attributed 100 for analyses purposes)
ggplot(Elevation, aes(x = Elevation_Paracou_depth1, y = final_depth)) +
  geom_point(data = subset(Elevation, final_depth != 100)) +
  geom_smooth(data = subset(Elevation, final_depth != 100), method = "lm")

```

Assumptions for correlation test:
linearity, normality


##Contour line analysis

```{r import contour data}
#write_csv(Augur, "Em_Augur.csv")
#import data in Qgis

#read QGIS used data
Contour_40to50 <- read.csv("Clip_40to50.csv")
Contour_50to60 <- read.csv("Clip_50to60.csv")
Contour_60to70 <- read.csv("Clip_60to70.csv")
Contour_70to80 <- read.csv("Clip_70to80.csv")
Contour_80to90 <- read.csv("Clip_80to90.csv")
Contour_90to100 <- read.csv("Clip_90to100.csv")
Contour_100 <- read.csv("Clip_100.csv")

#assign new column to all conotour line dataframes to be able to class them correctly
Contour_100$HSD_class <- "100"
Contour_40to50$HSD_class <- "40to50"
Contour_50to60$HSD_class <- "50to60"
Contour_60to70$HSD_class <- "60to70"
Contour_70to80$HSD_class <- "70to80"
Contour_80to90$HSD_class <- "80to90"
Contour_90to100$HSD_class <- "90to100"

#create one contour line dataframe
Total_contour <- rbind(Contour_100, Contour_40to50, Contour_50to60, Contour_60to70, Contour_70to80, Contour_80to90, Contour_90to100)

```


```{r combine area data with contour data}
#import area data
Area_1 <- read.csv("Em_40to50.csv")
Area_2 <- read.csv("Em_50to60.csv") %>%
  na.omit
Area_3 <- read.csv("Em_60to70.csv")
Area_4 <- read.csv("Em_70to80.csv")
Area_5 <- read.csv("Em_80to90.csv")
Area_6 <- read.csv("Em_90to100.csv")
Area_7 <- read.csv("Em_100.csv")

#assign new column to all area dataframes to be able to class them correctly
Area_7$HSD_class <- "100"
Area_1$HSD_class <- "40to50"
Area_2$HSD_class <- "50to60"
Area_3$HSD_class <- "60to70"
Area_4$HSD_class <- "70to80"
Area_5$HSD_class <- "80to90"
Area_6$HSD_class <- "90to100"

#get total area per dataframe (so sum areas in each dataframe)
# List of Area dataframes
area_dfs <- list(Area_1, Area_2, Area_3, Area_4, Area_5, Area_6, Area_7)

# Function to add area_class column to each dataframe
add_area_class_column <- function(df) {
  area_class <- sum(df$Area)   # Calculate the sum of 'Area' column within the dataframe
  df$area_class <- area_class  # Add a new column with the total area for this dataframe
  return(df)
}

# Apply the function to each dataframe in the list
area_dfs_with_area_class <- lapply(area_dfs, add_area_class_column)

# Assign the updated dataframes back to their respective variables
Area_1 <- area_dfs_with_area_class[[1]]
Area_2 <- area_dfs_with_area_class[[2]]
Area_3 <- area_dfs_with_area_class[[3]]
Area_4 <- area_dfs_with_area_class[[4]]
Area_5 <- area_dfs_with_area_class[[5]]
Area_6 <- area_dfs_with_area_class[[6]]
Area_7 <- area_dfs_with_area_class[[7]]

#create one area dataframe
Area <- rbind(Area_1, Area_2, Area_3, Area_4, Area_5, Area_6, Area_7) %>%
  distinct(HSD_class, .keep_all = TRUE) %>%
  select(c("HSD_class", "area_class"))

#create merged dataframe so every class also has the area it covers
Merged_contour <- merge(Area, Total_contour, by.x = "HSD_class", by.y = "HSD_class")

#creata dataframe with area only per HSD class
SumArea <- Merged_contour %>%
  distinct(area_class, .keep_all = TRUE) %>%
  select(area_class, HSD_class)



```



```{r AGB dataframe creation}
#create dataframe with mean DBH and amount of trees and species richness per HSD_class
AGB_contour <- Merged_contour %>%
  group_by(HSD_class) %>%
  mutate(
    full_species = paste(Genus, species, sep = " "),
    mean_DBH = mean(DBH, na.rm = TRUE)
  ) %>%
  summarise(
    amount_trees = n(),
    sp_richness = n_distinct(full_species),
    trees_per_area = amount_trees / area_class,
    sp_richness_area = sp_richness / area_class,
    mean_DBH = mean(mean_DBH, na.rm = TRUE)
  ) %>%
  distinct(HSD_class, .keep_all = TRUE) %>%
  merge(SumArea, by.x = "HSD_class", by.y = "HSD_class")
  
AGB_contour$HSD_class <- as.factor(AGB_contour$HSD_class)
Merged_contour$HSD_class <- as.factor(Merged_contour$HSD_class)

```

```{r visual mean DBH}

ggplot(data = AGB_contour, aes(HSD_class, mean_DBH)) + geom_boxplot() + geom_point()

```

```{r}

M1 <- lm(Merged_contour$DBH ~ as.factor(Merged_contour$HSD_class))
summary(M1)
autoplot(M1)
```


for mean DBH consider HSD as continuous and see if there is a relationship, also look at max DBH (from the total DBH measurements to also check whether there is a link between this)

```{r DBH}

ggplot(Merged_contour, aes(x = HSD_class, y = DBH)) + geom_boxplot()

# Filter data for DBH values between 0 and 10
filtered_DBH <- subset(Merged_contour, DBH >= 0 & DBH <= 10)

# Plot the filtered data
ggplot(data = filtered_DBH, aes(HSD_class, DBH)) +
  geom_boxplot() +
  geom_point()

```



```{r}
AGB_contour$HSD_cont = c(105, 45, 55,65, 75, 85, 95)

glm_trees <- glm(amount_trees ~ HSD_cont, data = AGB_contour, family = "poisson")

glm_trees <- glm(trees_per_area ~ HSD_cont, data = AGB_contour, family ="poisson")
```















##############################################################################################
##############################################################################################

## Buffer zone analysis
 no idea abandoned now.

```{r create Augur dataframe}

Augur <- dataAugur2022 %>%
  select(c("sondage_N", "arbre_plus_proche", "topo", "depth_sup", "Texture_2023"))

#create new texture variable that contains some non-corrected textures
Augur$final_texture <- ifelse(
  is.na(dataAugur2022$Texture_2023) & !(dataAugur2022$sondage_N %in% c("15.1", "15.2", "15.5", "15.7", "19.5", "19.7", "20.5")),
  dataAugur2022$texture,
  dataAugur2022$Texture_2023
)

#create new column with textures divided in three classes based upon their presence of silt
Augur$Silt_class <- ifelse(Augur$final_texture == "NA", NA, ifelse(
  Augur$final_texture %in% c("A", "Alo", "AS"), "low", ifelse(Augur$final_texture %in% c("SL", "SA", "S"), "intermediate", "high")))


Augur <- Augur %>% 
  select(c("sondage_N", "arbre_plus_proche", "topo", "depth_sup", "Silt_class", "final_texture")) %>%
  na.omit()

```

!There are multiple DBH measurements because some trees have multiple stems! => only keep biggest one


```{r define silt appearance depth for every Augur point and merge with botany data}

#creata dataframe in which for every Augur point you have defined depth at which silt concentration becomes high (or if no high it is 100 because consider it as "usefull soil for tree)

Augur <- Augur %>% 
  group_by(sondage_N) %>%  #group by Augur
  mutate(depth = ifelse(any(Silt_class == "high"), 
                         min(depth_sup[Silt_class == "high"]), 
                         100) ) %>%
  left_join(Botany, by = c("arbre_plus_proche" = "TreeID")) %>%
  group_by(sondage_N) %>%
  filter(DBH == max(DBH)) %>%
  distinct(sondage_N, .keep_all = TRUE) %>%
  select(c("sondage_N", "arbre_plus_proche", "topo", "depth", "DBH", "Family", "Genus", "species", "Xutm", "Yutm"))
  
```

Points are grouped by distance from center point (arbre_plus_proche)

```{r create good buffer dataframe}
write_csv(Augur, "Em_Augur.csv")
#import data in Qgis

Buffer_points <- read.csv("Em_bufferpoints.csv")


AGB_buffer <- Buffer_points %>%
  group_by(sondage_N) %>%
  mutate(full_species = paste(Genus, species, sep = " ")) %>%
  summarise(amount_trees = n(),
            sp_richness = n_distinct(full_species)
            ) %>%
  merge(Elevation, by.x = 'sondage_N', by.y = 'sondage_N') %>%
  select(c("sondage_N", "sp_richness", "amount_trees", "Elevation_Paracou_depth1"))

AGB_buffer <- AGB_buffer %>% rename_at('Elevation_Paracou_depth1', ~'elevation')

Final <- Augur %>%
  merge(AGB_buffer, by.x = 'sondage_N', by.y = 'sondage_N' )

```

#### data visualisation

```{r quick plots}
plot(Final$depth, Final$amount_trees)
plot(Final$depth, Final$sp_richness)
plot(Final$depth, Final$DBH)
```

limon and hummus link?


#### test if there is an effect of the depth of the silt horizon appearance on the number of trees

it might be interesting to look at type1 test because then you can put importance to your first variables that you put in

```{r amount of trees in buffer zone}
library(MASS)
M1 <- glm.nb(amount_trees ~ elevation*depth, data = Final)
M2 <- glm.nb(amount_trees ~ elevation + depth, data = Final)
summary(M1)
summary(M2)

```

very difficult to interpret these results as the predictor variables are strongly correlated, which 


```{r aboveground biomass}
M0 <- lm(Final$amount_trees ~ 1)
M1 <- lm(Final$amount_trees ~ Final$elevation)
M2 <- lm(Final$amount_trees ~ Final$depth)
M3 <- lm(Final$amount_trees ~ Final$elevation + Final$depth, family = "poisson")
M4 <- glm(Final$amount_trees ~ Final$elevation*Final$depth, family = "poisson")
summary(M4)
summary(M3)
Anova(M4)
anova(M4)  #if you take everything that depth also explains inside the topo (so sequence matters) then topo significantly explains the amount of trees

#check assumptions for overdispersion for poisson regression
overdisp_fun <- function(model) { rdf <- df.residual(model) 
rp <- residuals(model,type="pearson") 
Pearson.chisq <- sum(rp^2) 
prat <- Pearson.chisq/rdf 
pval <- pchisq(Pearson.chisq, df=rdf, lower.tail=FALSE) 
c(chisq=Pearson.chisq,ratio=prat,rdf=rdf,p=pval) } 
overdisp_fun(M1)

install.packages("AER")
library(AER)
dispersiontest(M4)


#kruskal?

autoplot(M4)  #assumptions do not seem to be met!
shapiro.test(Final$elevation)
shapiro.test(Final$depth)
shapiro.test(Final$amount_trees)
hist(Final$amount_trees)

# Anova(M0,M3)  #is there a difference by adding both depth and elevaiton in model
# Anova(M1, M3)   #significant effect of adding depth to model with only elevation
# 
# Anova(M0, M1)  #significant effect of adding elevation
# Anova(M1, M2)  #significant effect of adding depth to model with only elevation
# Anova(M0, M2)  #significant effect of depth on model with nothing
# Anova(M3, M4)
# Anova(M3, M2)  #how interpreting this again?

```



```{r DBH}

M0 <- lm(Final$DBH ~ 1)
M1 <- lm(Final$DBH ~ Final$elevation)
M2 <- lm(Final$DBH ~ Final$depth)
M3 <- lm(Final$DBH ~ Final$elevation + Final$depth)
M4 <- lm(Final$DBH ~ Final$elevation*Final$depth)



# Anova(M0, M1)    #significant effect of adding elevation
# Anova(M1, M2)    #significant effect of adding depth to model with only elevation (depth explains also things)
# Anova(M0, M2)   #significant effect of adding depth to model with nothing
# Anova(M0, M3) 
# Anova(M3, M4)   #confused with interpretation
# 
# autoplot(M1)   #assumptions do not seem to be completed??
# summary(M3) #how come here then no significance?



autoplot(M4)
shapiro.test(Final$DBH)

```



```{r species richness}

library(MASS)
# Fit a Negative Binomial regression model
negbin_model <- glm.nb(amount_trees ~ elevation * depth, data = Final)

# View summary of the model
summary(negbin_model)

M4 <- glm(Final$sp_richness ~ Final$elevation*Final$depth, family = "poisson")
summary(M4)
Anova(M4)
autoplot(M4)
shapiro.test(Final$sp_richness)
hist(Final$sp_richness)
dispersiontest(M4)
```




