---
title: "pedo_Auger_Analysis"
author: "EmilieSanvito"
date: "2023-10-05"
output: html_document
---
###Pedologie projet

##data organization

```{r libraries}
#to empty your work environment
rm(list=ls()) 


library(tidyverse)
library(readxl)
library(dplyr)

#install.packages("ggforce")
library(ggforce)   #look again why I used it
library(knitr)

library(geosphere)  #library for calculating distances of latitudes


#install.packages("memoiR")
#library(memoiR)

```

```{r upload and structure data}
#import data from last year project (36 Auger in the P16)
dataAuger2022 <- read_excel("DataAuger2022.xlsx", na = "NA")  

#create a new column for topography that only contains the number of the topography 
dataAuger2022$topo <- as.numeric(gsub("[^0-9]+", "", dataAuger2022$topographie))
#6: bas fonds
#5: versant bas de pente
#4: versant mi-pente
#3: versant haut de pente
#2: ...?
#1: plateau

#import botany data
Botany <- read_excel("DataAuger2022.xlsx", na = "NA", sheet = "Data Giacomo")  

#remove NA objects
Botany <- Botany %>% 
  na.omit  

```

```{r rename titles in data}

dataAuger2022 <- dataAuger2022 %>% rename_at('% pente', ~'pente')
dataAuger2022 <- dataAuger2022 %>% rename_at('Numéro horizon', ~'horizon')
dataAuger2022 <- dataAuger2022 %>% rename_at('profondeur limite inférieure (cm)2', ~'depth_inf')
dataAuger2022 <- dataAuger2022 %>% rename_at('profondeur limite supérieure (cm)', ~'depth_sup')
dataAuger2022 <- dataAuger2022 %>% rename_at('Epaisseur (cm)', ~'epaisseur')
dataAuger2022 <- dataAuger2022 %>% rename_at('Texture corrigée 2023', ~'Texture_2023')  #idk why it doesn't work here
dataAuger2022 <- dataAuger2022 %>% rename_at('EG %', ~'stone_elements')
dataAuger2022 <- dataAuger2022 %>% rename_at('Réserve eau utile (mm) NEW...35', ~'water_reservoir')

```

We have 36 Auger points, of which some do not have corrected texture analysis so we do not consider these (22) and of these 22 there are 17 that are on the slope. Of these 17 only 13 have high silt class present in their texture data.

Of the 22 texture available, there are 16 that have high texture present


```{r}
Auger <- dataAuger2022 %>% 
  select(c("sondage_N", "depth_sup", "texture", "Texture_2023", "topo", "arbre_plus_proche"))

Auger$final_texture <- ifelse(
  is.na(dataAuger2022$Texture_2023) & !(dataAuger2022$sondage_N %in% c("15.1", "15.2", "15.5", "15.7", "19.5", "19.7", "20.5")),
  dataAuger2022$texture,
  dataAuger2022$Texture_2023
)

#create dataframe with only final texture as texture, and then only eliminate the rows for which we have not data of
Auger_cor <- Auger %>%
  select(c("sondage_N", "depth_sup", "final_texture", "topo", "arbre_plus_proche")) %>%
  na.omit

#create new column with textures divided in three classes based upon their presence of silt
Auger_cor$Silt_class <- ifelse(Auger_cor$final_texture %in% c("A", "Alo", "AS"), "low", ifelse(Auger_cor$final_texture %in% c("SL", "SA", "S"), "intermediate", "high"))

#creata dataframe in which for every Auger point you have defined depth at which silt concentration becomes high, or if intermediate that it is 110 (!!Important to check this)
Auger_cor_2 <- Auger_cor %>%
  group_by(sondage_N) %>%
  filter(Silt_class == "high") %>%
  arrange(sondage_N, depth_sup) %>%
  distinct(sondage_N, .keep_all = TRUE) %>%
  select(sondage_N, depth_sup, arbre_plus_proche, topo) %>%
  merge(Botany, by.x = 'arbre_plus_proche', by.y = 'TreeID')

# Set depth_sup to 110 for "intermediate" Silt_class
Auger_cor <- Auger_cor %>%
  group_by(sondage_N) %>%
  mutate(depth_sup = ifelse(all(Silt_class != "high"), 110, depth_sup))

```

Make a new column in which the textures are grouped based on the importance of silt present:

```{r}
#filter out all data that isn't on the slope (drainage type DLS) and make smaller usable dataframe
Auger <- dataAuger2022 %>% 
  filter(topo %in% c("5", "4", "3")) %>%
  select(c("sondage_N", "Texture_2023", "depth_sup", "arbre_plus_proche", "topo")) 

#take out NA variables
Auger <- Auger %>% 
  na.omit   

#create new column with textures divided in three classes based upon their presence of silt
Auger$Silt_class <- ifelse(Auger$Texture_2023 %in% c("A", "Alo", "AS"), "low", ifelse(Auger$Texture_2023 %in% c("SL", "SA", "S"), "intermediate", "high"))

#make a more precise df with variables we will use
Botany <- Botany %>% 
  select(c("TreeID", "Family", "Genus", "species", "DBH", "Xutm", "Yutm"))


```

!There are multiple DBH measurements because some trees have multiple stems!


```{r define silt appearance depth}

#creata dataframe in which for every Auger point you have defined depth at which silt concentration becomes high
Auger <- Auger %>% 
  group_by(sondage_N) %>%             #group by Auger
  filter(Silt_class == "high") %>%    #get only Augers for which the silt concentration is high
  arrange(sondage_N, depth_sup) %>%   #arrange the data so that every measurement in one Auger is arranged with depth
  distinct(sondage_N, .keep_all = TRUE) %>%  #keep only one value per Auger (the first depth)
  select(sondage_N,depth_sup, arbre_plus_proche, topo) %>% #maintain only three variables from the dataframe
  merge(Botany, by.x = 'arbre_plus_proche', by.y = 'TreeID' )   #merge with botany dataframe for common values of treeID and arbre plus proche

```

Create dataframe where points are grouped by distance from center point (arbre_plus_proche)

```{r create good buffer dataframe}

#write_csv(Botany, "Botany_export.csv")      
#export data to QGis

#upload data that contains zones of 5m around center Auger points
Buffer_points <- read.csv("Final_intersection.csv")

AGB_buffer <- Buffer_points %>%
  group_by(sondage_N) %>%
  summarise(amount_trees = n(),
            sp_richness = n_distinct(species)
            )

AGB_buffer$DBH <- Auger$DBH   #problem to fix

Final_df <- Auger %>%
  select(sondage_N, depth_sup, topo) %>%
  merge(AGB_buffer, by.x = 'sondage_N', by.y = 'sondage_N' )


   
# result <- Buffer_points %>%
# group_by(sondage_N, Family) %>%
# summarise(count = n()) %>%
# arrange(desc(count)) %>%
# slice(1) %>%
# ungroup() %>%
# group_by(sondage_N) %>%
# summarise(most_abundant_family = Family[1],
#           most_abundant_count = count[1],
#           total_families_seen = n_distinct(Family))


```

```{r}
Elevation_exact <- read.csv("Elevation_exact.csv")

hist(log(Elevation_exact$Elevation_Paracou_depth1))

Elevation_exact <- Elevation_exact %>%
  na.omit
cor(Elevation_exact$depth_sup, Elevation_exact$Elevation_Paracou_depth1, method = "pearson")
```
I will make a new column that includes all textures, no NA anymore, so to keep all Augers
```{r ugh pause on this part}

#creates a new column for all textures combining the corrected and the not corrected ones (if topography is 5 or 6 and if it is not three points decided by visual that they are not good to)
dataAuger2022$final_texture <- ifelse(
  is.na(dataAuger2022$Texture_2023) & (dataAuger2022$topo == 5 | dataAuger2022$topo == 6) & !(dataAuger2022$sondage_N %in% c("15.1", "15.5", "15.7")),
  dataAuger2022$texture,
  dataAuger2022$Texture_2023
)


Greta1 <- dataAuger2022 %>% 
  select(c("sondage_N", "Texture_2023", "final_texture", "texture", "depth_sup", "arbre_plus_proche", "topo"))

#create new column with textures divided in three classes based upon their presence of silt
Greta1$Silt_class <- ifelse(Greta1$final_texture %in% c("A", "Alo", "AS"), "low", ifelse(Greta1$final_texture %in% c("SL", "SA", "S"), "intermediate", ifelse(Greta1$final_texture == "NA", "NA", "high")))

Greta_merged <- merge(Greta1, Botany, by.x = "arbre_plus_proche", by.y = "TreeID") %>%
  group_by(sondage_N) %>%             # Regroup by "sondage_N"
  filter(DBH == max(DBH)) %>%         # Filter to keep rows with the highest DBH
  distinct(sondage_N, .keep_all = TRUE) # Keep only one row per sondage_N

write_csv(Greta_merged, "Greta.csv")   #for greta

Greta <- Greta1 %>%
  group_by(sondage_N) %>%             # Group by Auger
  filter(Silt_class == "high") %>%    # Get only Augers with high silt concentration
  arrange(sondage_N) %>%              # Arrange data by "sondage_N"
  left_join(Botany, by = c("arbre_plus_proche" = "TreeID")) %>% # Left join with Botany
  group_by(sondage_N) %>%             # Regroup by "sondage_N"
  filter(DBH == max(DBH)) %>%         # Filter to keep rows with the highest DBH
  distinct(sondage_N, .keep_all = TRUE) %>% # Keep only one row per sondage_N
  select(sondage_N, depth_sup, arbre_plus_proche, topo, DBH, Xutm, Yutm) # Maintain selected variables


```


we want a dataframe to be able to make a nice map of the different depths at which silt occurs in the whole 4ha plot that was studied with the Augers
```{r map part}

#filter out all data that isn't on the slope (drainage type DLS) and make smaller usable dataframe
map_Auger_NA <- dataAuger2022  %>%
  select(c("sondage_N", "Texture_2023", "depth_sup", "arbre_plus_proche", "topo")) 

#take out NA variables
map_Auger <- map_Auger_NA %>% 
  na.omit   

#create new column with textures divided in three classes based upon their presence of silt
map_Auger$Silt_class <- ifelse(map_Auger$Texture_2023 %in% c("A", "Alo", "AS"), "low", ifelse(map_Auger$Texture_2023 %in% c("SL", "SA", "S"), "intermediate", "high"))

map_Auger <- map_Auger %>%
  group_by(sondage_N) %>%             # Group by Auger
  filter(Silt_class == "high") %>%    # Get only Augers with high silt concentration
  arrange(sondage_N) %>%              # Arrange data by "sondage_N"
  left_join(Botany, by = c("arbre_plus_proche" = "TreeID")) %>% # Left join with Botany
  group_by(sondage_N) %>%             # Regroup by "sondage_N"
  filter(DBH == max(DBH)) %>%         # Filter to keep rows with the highest DBH
  distinct(sondage_N, .keep_all = TRUE) %>% # Keep only one row per sondage_N
  select(sondage_N, depth_sup, arbre_plus_proche, topo, DBH, Xutm, Yutm) # Maintain selected variables

#export map data to csv to be able to use it in QGIS
write_csv(map_Auger, "map_Augerdata.csv")

#created this df to be able to know which sondage_N have only intermediate/low silt class concentration
df <- map_Auger %>%
  group_by(sondage_N) %>%     
  filter(Silt_class == "high")

lost_sondage_N <- map_Auger %>%
  select(sondage_N) %>%
  anti_join(df, by = "sondage_N") %>%
  distinct(sondage_N)

print(lost_sondage_N)

```


## data visualisation

```{r quick plots}

plot(Final_df$depth_sup, Final_df$amount_trees)
plot(Final_df$depth_sup, Final_df$sp_richness)
plot(Final_df$depth_sup, Final_df$DBH)
```

## test if there is an effect of the depth of the silt horizon appearance on the number of trees

```{r}

shapiro.test(Final_df$depth_sup)
shapiro.test(Final_df$amount_trees)   #not normal?
shapiro.test(Final_df$sp_richness)

library(ggfortify)
M1 <- lm(Final_df$amount_trees ~ Final_df$depth_sup)
summary(M1)
autoplot(M1)

library(car)   #library for Anova function

Final_df$topo <- as.factor(Final_df$topo)

M2 <- lm(Final_df$amount_trees ~ Final_df$topo)
summary(M2)
Anova(M2)

M3 <- lm(Final_df$amount_trees ~ Final_df$topo*Final_df$depth_sup)
summary(M3)
Anova(M3)
```


```{r}
Anova(M1)
Anova(M2)
Anova(M3)

#check correlation between depth and topo!!
#make boxplot of profondeur de limon with topography, be aware of this

#if there is a correlation between the silt depth and distance of bas fonds => will complicate your things because we know there is a link between topo and species so then you cannot say anything 

#it might be interesting to look at type1 test because then you can put importance to your first variables that you put in
```


## extra

```{r code to find package of a function}
#install.packages("sos")  #package for function find Fn,
library(sos)
findFn("geosphere")  #function to learn which package is necessary for your function
```


