---
title: "pedo_Augur_Analysis"
author: "EmilieSanvito"
date: "2023-10-05"
output: html_document
---
###Pedologie projet

##data organization

```{r libraries}
#empty your work environment
rm(list=ls()) 

#load all libraries
library(tidyverse)
library(readxl)
library(dplyr)

#library(ggforce)   #look again why I used it
library(knitr)

library(car)          #for anvoa
library(ggfortify)   #for autoplot function

library(datasets)   #library for KW test
library(FSA)        #library for dunn test

library(viridis) #to use color gradient
library(ggmosaic) #to do mosaic plot
# save(list = ls(all.names = TRUE), file = "pedoP16_data-AUGER.rda") #save all data

library(vdc)
```

```{r upload and structure data}
#--upload and structure data
#import data from last year project (36 Augur in the P16)
dataAugur2022 <- read_excel("DataAuger2022.xlsx", na = "NA")  

#create a new column for topography that only contains the number of the topography 
dataAugur2022$topo <- as.numeric(gsub("[^0-9]+", "", dataAugur2022$topographie))

#import botany data
Botany <- read_excel("DataAuger2022.xlsx", na = "NA", sheet = "Data Giacomo")

#remove NA objects and select specific variables of interest
Botany <- Botany %>% 
  na.omit %>%
  select(c("TreeID", "Family", "Genus", "species", "DBH", "Xutm", "Yutm"))
```

```{r rename titles in Augur data}
#--rename titles in Augur data
dataAugur2022 <- dataAugur2022 %>% rename_at('% pente', ~'pente')
dataAugur2022 <- dataAugur2022 %>% rename_at('Numéro horizon', ~'horizon')
dataAugur2022 <- dataAugur2022 %>% rename_at('profondeur limite inférieure (cm)2', ~'depth_inf')
dataAugur2022 <- dataAugur2022 %>% rename_at('profondeur limite supérieure (cm)', ~'depth_sup')
dataAugur2022 <- dataAugur2022 %>% rename_at('Epaisseur (cm)', ~'epaisseur')
dataAugur2022 <- dataAugur2022 %>% rename_at('Texture corrigée 2023', ~'Texture_2023')
dataAugur2022 <- dataAugur2022 %>% rename_at('EG %', ~'stone_elements')
dataAugur2022 <- dataAugur2022 %>% rename_at('Réserve eau utile (mm) NEW...35', ~'water_reservoir')
```

## Include new corrected texture data

```{r part for correlation test}
#create a cleaner dataframe with only necessary informations
Augur_cor <- dataAugur2022 %>% 
  select(c("sondage_N", "depth_sup", "texture", "Texture_2023", "topo", "arbre_plus_proche", "mica"))

#create new texture variable that contains some additional corrected textures
Augur_cor$final_texture <- ifelse(
  is.na(dataAugur2022$Texture_2023) & !(dataAugur2022$sondage_N %in% c("15.1", "15.2", "15.5", "15.7", "19.5", "19.7", "20.5")),
  dataAugur2022$texture,
  dataAugur2022$Texture_2023
)

#create dataframe with only final texture as texture, and then only eliminate the rows for which we have no data for
Augur_cor <- Augur_cor %>%
  select(c("sondage_N", "depth_sup", "final_texture", "topo", "mica")) %>%
  na.omit

#create new column with textures divided in three classes based upon their presence of silt
Augur_cor$Silt_class <- ifelse(Augur_cor$final_texture %in% c("A", "Alo", "AS"), "low", ifelse(Augur_cor$final_texture %in% c("SL", "SA", "S"), "intermediate", "high"))
```


## Test mica correlation with silt content

```{r}
# filter out all data that isn't on the slope (drainage type DLS)
Augur_cor_mica <- Augur_cor %>%
  filter(topo %in% c("5", "4", "3"))

# set mica and silt_class as factor 
Augur_cor_mica$mica=as.factor(Augur_cor_mica$mica)
Augur_cor_mica$Silt_class=as.factor(Augur_cor_mica$Silt_class)

# Perform the chi-squared test (don't take ordinal )
chi_sq_test <- chisq.test(Augur_cor_mica$mica, Augur_cor_mica$Silt_class)
print(chi_sq_test)

# Create a contingency table
contingency_table <- table(Augur_cor_mica$mica, Augur_cor_mica$Silt_class)
print(contingency_table)

# Obtain Cramér's V and other statistics
assoc_stats <- assocstats(contingency_table)
print(assoc_stats)

#reverte silt class for ease of reading plot
Augur_cor_mica$Silt_class_revert <- factor(Augur_cor_mica$Silt_class, 
                                  levels = rev(levels(Augur_cor_mica$Silt_class)))

colSilt <- viridis(3) #color for silt content classes

#mosaic plot of silt class with mica
augerPlot_micaCor <- ggplot(data=Augur_cor_mica) +
   geom_mosaic(aes(x = product(Silt_class_revert, mica), 
                   fill = Silt_class_revert))+
   labs(title = "Mica Silt relation") +
   scale_fill_manual(name = "silt content", values = setNames(colSilt, levels(Augur_cor_mica$Silt_class_revert)))+
   theme_minimal()
augerPlot_micaCor
```


## check for correlation between topography and high silt depth occurences

```{r part for correlation test}
#For every Augur point you define depth at which silt concentration becomes high, or if intermediate that it is 100
Augur_cor <- Augur_cor %>%
  group_by(sondage_N) %>%
  mutate(
    final_depth = ifelse(any(Silt_class == "high"), 
                         min(depth_sup[Silt_class == "high"]), 
                         100)) %>%
  ungroup() %>%
  distinct(sondage_N, .keep_all = TRUE) %>%
  select(sondage_N, final_depth, topo)

#import elevation data of topography
Elevation <- read.csv("Elevation_exact.csv")

#merge two dataframes 
Elevation <- Elevation %>%
  select(c("sondage_N", "Elevation_Paracou_depth1")) %>%
  merge(Augur_cor, by.x = 'sondage_N', by.y = 'sondage_N')

#correlation test between topography and high silt depth appearance, spearman method instead of pearson due to non-normality (of final depth because much more values of no HSD appearance)
cor(Elevation$Elevation_Paracou_depth1, Elevation$final_depth, method = "spearman")
cor.test(Elevation$Elevation_Paracou_depth1, Elevation$final_depth, method = 
c("spearman"))

#Filter out rows where final_depth is 100
Elevation_filtered <- Elevation[Elevation$final_depth != 100,]

# Correlation test between topography and high silt depth appearance, pearson method
shapiro.test(Elevation_filtered$final_depth)
shapiro.test(Elevation_filtered$Elevation_Paracou_depth1)

cor(Elevation_filtered$Elevation_Paracou_depth1, Elevation_filtered$final_depth, method = "pearson")
cor.test(Elevation_filtered$Elevation_Paracou_depth1, Elevation_filtered$final_depth, method = "pearson")

```

```{r data visualisation for correlation}
#create graph without Augurs that do not have high silt occurrences (they are all attributed 100 for analyses purposes)
ggplot(Elevation, aes(x = Elevation_Paracou_depth1, y = final_depth)) +
  geom_point(data = subset(Elevation, final_depth <= 100)) +
  geom_smooth(data = subset(Elevation, final_depth <= 100), method = "lm") +
  theme_minimal() + 
  labs(x = "Elevation (m)", y = "HSD (cm)", title = "HSD-Elevation relationship")
```

##Contour line analysis

```{r import contour data}
#import data in Qgis
#read QGIS used data
Contour_40to50 <- read.csv("Correct_Clip_40to50.csv")
Contour_50to60 <- read.csv("Correct_Clip_50to60.csv")
Contour_60to70 <- read.csv("Correct_Clip_60to70.csv")
Contour_70to80 <- read.csv("Correct_Clip_70to80.csv")
Contour_80to90 <- read.csv("Correct_Clip_80to90.csv")
Contour_90to100 <- read.csv("Correct_Clip_90to100.csv")
Contour_100 <- read.csv("Correct_Clip_100.csv")

#assign new column to all contour line dataframes to be able to class them correctly
Contour_100$HSD_class <- "No High Silt"
Contour_40to50$HSD_class <- "40-50"
Contour_50to60$HSD_class <- "50-60"
Contour_60to70$HSD_class <- "60-70"
Contour_70to80$HSD_class <- "70-80"
Contour_80to90$HSD_class <- "80-90"
Contour_90to100$HSD_class <- "90-100"

#create one contour line dataframe
Total_contour <- rbind(Contour_100, Contour_40to50, Contour_50to60, Contour_60to70, Contour_70to80, Contour_80to90, Contour_90to100)
```


```{r combine area data with contour data}
#import area data
Area_1 <- read.csv("Correct_Poly_40to50.csv")
Area_1 <- Area_1 %>%
  select(id, Area_1)
Area_1$Area <- Area_1$Area_1 
Area_1 <- Area_1 %>%
  select(id, Area)

Area_2 <- read.csv("Correct_Em_50to60.csv")
Area_2$Area <- Area_2$area_1 
Area_2 <- Area_2 %>%
  select(id, Area)

Area_3 <- read.csv("Correct_Em_60to70.csv")

Area_4 <- read.csv("Correct_Poly_70to80.csv")
Area_4 <- Area_4 %>%
  select(id, Area_1)
Area_4$Area <- Area_4$Area_1 
Area_4 <- Area_4 %>%
  select(id, Area)

Area_5 <- read.csv("Correct_Poly_80to90.csv")
Area_5 <- Area_5 %>%
  select(id, Area_1)
Area_5$Area <- Area_5$Area_1 
Area_5 <- Area_5 %>%
  select(id, Area)

Area_6 <- read.csv("Correct_Poly_90to100.csv")
Area_6 <- Area_6 %>%
  select(id, Area_1)
Area_6$Area <- Area_6$Area_1 
Area_6 <- Area_6 %>%
  select(id, Area)

Area_7 <- read.csv("Correct_Poly_100.csv")
Area_7 <- Area_7 %>%
  select(id, Area_1)
Area_7$Area <- Area_7$Area_1 
Area_7 <- Area_7 %>%
  select(id, Area)

#assign new column to all area dataframes to be able to class them correctly
Area_7$HSD_class <- "No High Silt"
Area_1$HSD_class <- "40-50"
Area_2$HSD_class <- "50-60"
Area_3$HSD_class <- "60-70"
Area_4$HSD_class <- "70-80"
Area_5$HSD_class <- "80-90"
Area_6$HSD_class <- "90-100"

#get total area per dataframe (so sum areas in each dataframe)
# List of Area dataframes
area_dfs <- list(Area_1, Area_2, Area_3, Area_4, Area_5, Area_6, Area_7)

# Function to add area_class column to each dataframe
add_area_class_column <- function(df) {
  area_class <- sum(df$Area)   # Calculate the sum of 'Area' column within the dataframe
  df$area_class <- area_class  # Add a new column with the total area for this dataframe
  return(df)
}

# Apply the function to each dataframe in the list
area_dfs_with_area_class <- lapply(area_dfs, add_area_class_column)

# Assign the updated dataframes back to their respective variables
Area_1 <- area_dfs_with_area_class[[1]]
Area_2 <- area_dfs_with_area_class[[2]]
Area_3 <- area_dfs_with_area_class[[3]]
Area_4 <- area_dfs_with_area_class[[4]]
Area_5 <- area_dfs_with_area_class[[5]]
Area_6 <- area_dfs_with_area_class[[6]]
Area_7 <- area_dfs_with_area_class[[7]]

#create one area dataframe
Area <- rbind(Area_1, Area_2, Area_3, Area_4, Area_5, Area_6, Area_7) %>%
  distinct(HSD_class, .keep_all = TRUE) %>%
  select(c("HSD_class", "area_class"))

#create merged dataframe so every class also has the area it covers
Merged_contour <- merge(Area, Total_contour, by.x = "HSD_class", by.y = "HSD_class")

#consider HSD class as a factor
Merged_contour$HSD_class <- as.factor(Merged_contour$HSD_class)

#create a continuous variable of HSD
Merged_contour <- Merged_contour %>%
  mutate(HSD_cont = case_when(
    HSD_class == "40-50" ~ 44,
    HSD_class == "50-60" ~ 55,
    HSD_class == "60-70" ~ 67,
    HSD_class == "70-80" ~ 75,
    HSD_class == "80-90" ~ 85,
    HSD_class == "90-100" ~ 99,
    HSD_class == "No High Silt" ~ 105,
    # Add more conditions for other HSD_class values here
    TRUE ~ NA_real_
  ))

#creata dataframe with area only per HSD class
SumArea <- Merged_contour %>%
  distinct(area_class, .keep_all = TRUE) %>%
  select(area_class, HSD_class)
```



```{r AGB dataframe creation}
#create dataframe with mean DBH and amount of trees and species richness per HSD_class
AGB_contour <- Merged_contour %>%
  group_by(HSD_class) %>%
  mutate(
    full_species = paste(Genus, species, sep = " "),
    mean_DBH = mean(DBH, na.rm = TRUE)
  ) %>%
  summarise(
    amount_trees = n(),
    sp_richness = n_distinct(full_species),
    tree_density = amount_trees / area_class,
    sp_richness_density = sp_richness / area_class,
    mean_DBH = mean(mean_DBH, na.rm = TRUE)
  ) %>%
  distinct(HSD_class, .keep_all = TRUE) %>%
  merge(SumArea, by.x = "HSD_class", by.y = "HSD_class")

#create a continuous variable of HSD
AGB_contour$HSD_cont = c(105, 44, 55,67, 75, 85, 99)
AGB_contour <- AGB_contour %>% #add area in ha
  mutate(sp_richness_ha = sp_richness_density*10000,
         tree_density_ha = tree_density*10000) 

```


```{r analysis tree density}
#--analysis tree density
#do a general linear model with poisson distribution as mount_trees is a count
#offset parameter is used to take plots area into acount (weighting by area)
glm_density <- glm(amount_trees ~ HSD_cont, data = AGB_contour, family = poisson(link = "log"), offset = log(area_class))

summary(glm_density)

#plot tree density ~ HSD, with ha instead of square meters
augerPlot_density <- ggplot(AGB_contour, aes(x = HSD_class, y = tree_density_ha)) +
  geom_point() +
  labs(x = "HSD Class (cm)", y = "Tree density (per ha)", title = "(b)") +
  theme_minimal()
augerPlot_density

#check overdispersion
#If this parameter approaches 2 this might indicate over or under dispersion (and thus a bad fitting model). 
pp<- sum(resid(glm_density, type = "pearson")^2)
1 - pchisq(pp, glm_density$df.resid)

```

```{r analysis species richness density}
#--analysis species richness density
#as for density, do a glm as richness is a count
glm_richness <- glm(sp_richness ~ HSD_cont, data = AGB_contour, family = poisson(link = "log"), offset = log(area_class))

summary(glm_richness)

#plot sp richness per ha ~ HSD
augerPlot_richness <- ggplot(AGB_contour, aes(x = HSD_class, y = sp_richness_ha)) +
  geom_point() +
  labs(x = "HSD Class (cm)", y = "Species richness (per ha)", title = "(a)") +
  scale_y_continuous(breaks = seq(min(0), max(AGB_contour$sp_richness_ha), by = 200)) +
  theme_minimal()
augerPlot_richness

#check overdispersion
#If this parameter approaches 2 this might indicate over or under dispersion (and thus a bad fitting model). 
pp<- sum(resid(glm_richness, type = "pearson")^2)
1 - pchisq(pp, glm_richness$df.resid)
```

```{r visual mean DBH}
#plot DBH in function of different HSD classes
augerPlot_DBH <- ggplot(Merged_contour, aes(x = HSD_class, y = DBH)) + 
  geom_boxplot() + 
  labs(x = "HSD Class (cm)", y = "DBH", title = "(c)") +
  theme_minimal()
augerPlot_DBH


# Filter the data to exclude trees with DBH<=10
filtered_data <- subset(Merged_contour, DBH > 10)

# Create the plot with the filtered data
NEWaugerPlot_DBH <- ggplot(filtered_data, aes(x = HSD_class, y = DBH)) + 
  geom_boxplot() + 
  labs(x = "HSD Class (cm)", y = "DBH", title = "(c)") +
  theme_minimal()
NEWaugerPlot_DBH
```

```{r analysis of DBH with HSD}
#--analysis of DBH with HSD
#linear model between DBH and HSD corrected by log
model_DBH <- lm(Merged_contour$DBH ~ log(Merged_contour$HSD_cont))

#check assumptions with plots below
par(mfrow = c(2,2))
plot(model_DBH)

#non normal data, maybe make bigger groups of classes
#create a continuous variable of HSD
Merged_contour_new <- Merged_contour %>%
  mutate(HSD_class = case_when(
    HSD_class == "40-50" ~ 60,
    HSD_class == "50-60" ~ 60,
    HSD_class == "60-70" ~ 60,
    HSD_class == "70-80" ~ 80,
    HSD_class == "80-90" ~ 80,
    HSD_class == "90-100" ~ 80,
    HSD_class == "100" ~ 105,
    # Add more conditions for other HSD_class values here
    TRUE ~ NA_real_
  ))

#make it so the HSD_class is seen as a factor
Merged_contour_new$HSD_class <- as.factor(Merged_contour_new$HSD_class)

#plot the DBH and HSD class that are grouped together
ggplot(data = Merged_contour_new, aes(HSD_class, DBH)) + geom_boxplot()  #still no difference

#create model with fewer classes
model_DBH_new <- lm(Merged_contour_new$DBH ~ Merged_contour_new$HSD_cont)

#check assumptions with plots below
autoplot(model_DBH_new)                #nothing changed in assumptions either, still not met
#or
par(mfrow = c(2,2))
plot(model_DBH_new)

```
```{r filter out certain DBH}
# Filter data for DBH values between 0 and 10
filtered_DBH <- subset(Merged_contour, DBH >= 0 & DBH <= 10)

# Plot the filtered data
augerPlot_DBH_inf10 <- ggplot(data = filtered_DBH, aes(HSD_class, DBH)) +
  geom_boxplot() +
  geom_point() +
  labs(x = "HSD Class (cm)", y = "DBH (max 10)", title = "(d)") +
  theme_minimal()
augerPlot_DBH_inf10
```